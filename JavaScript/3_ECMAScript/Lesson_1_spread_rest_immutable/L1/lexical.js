// Лексический контекст или лексическое окружение — это механизм в JavaScript,
//     который позволяет функции во время её вызова получать доступ к переменным,
//     константам и всему, что ей нужно. Каждый раз при вызове функции создаётся
// что-то вроде объекта словаря, который записывает все значения переменных и
// констант внутри функции, а также тех переменных и констант вне функции, к
// которым она обращается. Посмотрим на примерах:
const lastName = "Petrov";
// lexical environment: { lastName: "Petrov" }
const getFullName = (firstName) => {
// lexical environment: { lastName: "Petrov", firstName:
//     <определяется в момент вызова функции> }
    const fullName = firstName + ' ' + lastName;
    // lexical environment: { lastName: "Petrov", firstName:
    //     <определяется в момент вызова функции>, fullName: <вычисляется в
    //     момент вызова функции> }
    console.log(fullName);
    return energy;
};
getFullName("Ivan"); // Ivan Petrov
// lexical environment в момент вызова функции становится таким:
// {lastName: "Petrov", firstName: "Ivan", fullName: "Ivan Petrov"}
// Когда функция только создаётся в коде, в её лексическом контексте ещё не
// определены многие переменные, но для них оставлен задел. В момент вызова
// функции они будут определены и заполнены. В этом примере скорость света
// определена как глобальная константа и будет доступна в функции. Если бы на её
// месте была переменная, то она попала бы в лексический контекст только в момент
// вызова функции, и значение будет использоваться то, которое будет в этой
// переменной на момент вызова функции. Это очень важный момент, который
// позволяет понять, почему при вызове функции мы часто получаем не тот результат,
// который хотели бы. Остальные переменные, аргументы и объявленные в самой
// функции переменные и константы до её вызова не имеют значений. В момент её
// вызова они будут записаны и использованы.
// Всё это сделано специально, чтобы каждый вызов функции исполнялся в своём
// отдельном мире, но мог взаимодействовать с внешним миром посредством
// передачи значений в лексический контекст. Именно из него функция получает
// значения и может их использовать.
// Разберём пример, как работает лексическое окружение, чтобы лучше понять его
// важность и проблематику его неправильного использования:
// Напишем функцию, которая будет строить дома: создадим массив функций, при
// вызове функции из каждого элемента массива должен выводиться номер дома.
const houses = [];
let i = 0;
while (i < 10) {
    let house = function () { // функция «дом»
        console.log(i); // выводит номер дома
    };
    houses.push(house);
    i++;
}
houses[0](); // 10 — у нулевого дома номер 10
houses[7](); // 10 — и у седьмого дома номер 10
// Как мы можем убедиться, все наши дома имеют номер 10, хотя в цикле мы давали
// им номера по порядку и они должны быть корректными. Так происходит из-за
// лексического контекста, который создаётся в момент вызова функции. Вызов
// функции, которая должна показать номер дома, происходит уже после выполнения
// цикла. Так как переменная i объявлена именно как переменная, то её значение на
// момент вызова функции становится равным 10, это результат выполнения цикла.
// Соответственно, при вызове функции выводится номер дома 10.
// Вот так выглядит лексическое окружение в момент выполнения функции house:
let house = function () { // функция «дом»
// лексическое окружение: { i: 10 }
    console.log(i); // выводит номер дома
};
// Для исправления такой ситуации необходимо хранить номер дома внутри блока
// цикла с использованием let:
const houses = [];
let i = 0;
while (i < 10) {
    let houseNumber = i; // Здесь мы создаём блочную переменную,
    // которая сохранит значение i для конкретной итерации цикла, и
    // именно её значение попадёт в лексическое окружение функции house.
    let house = function () { // функция «дом»
        console.log(houseNumber); // выводит номер дома
    };
    houses.push(house);
    i++;
}
houses[0](); // 0 — у нулевого дома номер 0
houses[7](); // 7 — и у седьмого дома номер 7
// Или внутри функции house:
const houses = [];
let i = 0;
while (i < 10) {
    let house = function () { // функция «дом»
        let houseNumber = i; // Здесь мы создаём блочную
        // переменную, которая сохранит значение i, и именно её значение
        // попадёт в лексическое окружение функции house.
        // console.log(houseNumber); // выводит номер дома
    };
    houses.push(house);
    i++;
}
houses[0](); // 0 — у нулевого дома номер 0
houses[7](); // 7 — и у седьмого дома номер 7
